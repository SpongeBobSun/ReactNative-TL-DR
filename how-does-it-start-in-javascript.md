## TL;DR

## Since you want to read it anyway...

In previous chapter, we ended with below code block - 

```objectivec
- (void)runApplication:(RCTBridge *)bridge
{
  //...Code removed to make it more clear for reading.
  [bridge enqueueJSCall:@"AppRegistry"
                 method:@"runApplication"
                   args:@[moduleName, appParameters]
             completion:NULL];
}
```

Which called `AppRegistry.runApplication` with 'module name' and 'parameters' as argument. So let's open the JavaScript project and navigate to `AppRegistry.js` to find out what's going on here.

_AppRegistry.js_

```js
runApplication(appKey: string, appParameters: any): void {
    //...Assertion code
    runnables[appKey].run(appParameters);
  },
```

The `runnables` is a global dictionary which held the `appKey => component` mapping. We've already registered our `App.js` with key `RNTLDR` in `index.js` of our project. This code is generated by `react-native` command line tool since we've created our app with it.

_index.js_

```js
import { AppRegistry } from 'react-native';
import App from './App';

AppRegistry.registerComponent('RNTLDR', () => App);
```

_AppRegistry.js_

```js
registerComponent(
    appKey: string,
    componentProvider: ComponentProvider,
    section?: boolean,
  ): string {
    runnables[appKey] = {
      componentProvider,
      run: appParameters =>
        renderApplication(
          componentProviderInstrumentationHook(componentProvider),
          appParameters.initialProps,
          appParameters.rootTag,
          wrapperComponentProvider && wrapperComponentProvider(appParameters),
        ),
    };
    if (section) {
      sections[appKey] = runnables[appKey];
    }
    return appKey;
  },
```

So the `run` function will call `renderApplication` to render our application. 

_renderApplication.js_

```js
function renderApplication<Props: Object>(
  RootComponent: React.ComponentType<Props>,
  initialProps: Props,
  rootTag: any,
  WrapperComponent?: ?React.ComponentType<*>,
) {
  invariant(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);

  let renderable = (
  
    /**
     * Bob's note:
     * `RootComponent` is our app's root component ('App.js')
     */
     
    <AppContainer rootTag={rootTag} WrapperComponent={WrapperComponent}>
      <RootComponent {...initialProps} rootTag={rootTag} />
    </AppContainer>
  );

  //...Async component check removed (still marked unstable in v52.0.0)

    renderable = (
      <AppContainerAsyncWrapper>{renderable}</AppContainerAsyncWrapper>
    );
  }

  ReactNative.render(renderable, rootTag);
}
```

This is pretty straight forward - first it will wrap our component in `AppContainer` , then it will render our app using `ReactNative.render`.

The `AppContainer` part is rather simple. I will not paste any code for this. If you looking into `AppContainer.js`, it basically wrapped 'yellow box', 'inspector' and our app root to a `View`. The previous two are for debugging use. It also injected the debug inspector directly in 'React DOM'.

So the key part is `ReactNative.render`. `ReactNative` module is defined in '\[your project root\]/node\_modules/react-native/Libraries/Renderer/shims/ReactNative.js'. And it will use different 'renderer' for debugging and production but they are basically the same.





